<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional">
<html><head><meta http-equiv="content-type" content="text/html" charset="utf-8">
<title>Конспект для курса "Линукс с нуля"</title>
<meta name="description" lang="ru" content="конспект лекций для начинающих изучать Linux (Unix) ">
<meta name="keywords" lang="ru" content="Линукс, Юникс, Гомель, Беларусь, конспект, обучение, курсы">
<meta name="keywords" lang="en" content="Linux, Unix, LUG, Gomel, Belarus, Oleg P. Philon, course, education">
<meta name="author" content="Олег П. Филон, Oleg P. Philon">
<meta name="copyright" content="&copy; FDL, Олег П. Филон">
<link rel="e-mail" href="mailto:smartcloud.by@gmail.com">
<meta name="date" content="апрель 2001">
<meta name="version" content="1.1">
<style type="text/css">
<!--
body, p, div, td, th, tr, form, ol, ul, li, input, textarea, select, a
	{ 	font-family: Verdana,Geneva,Arial,Helvetica,sans-serif;
		font-size: 11pt;
    }
body	{	background: white;
		margin: 3px;
    }
p 	{	display: block;
		text-align: justify;
		line-height: 120%;
		margin: 4px;
    }	
b 	{ 	font-weight: bold;
		color: blue;
    }
pre, code, tt { font: "Courier New", Courier, monospace;
		line-height: 120%;
		font-size: 11pt;
    }

a	{	font-family: Verdana,Geneva,Arial,Helvetica,sans-serif;
		font-size:12pt;
		text-decoration:underline;
		color: blue
    }
a:hover {	color: red
    }
-->
</style>
<script type="text/javascript" language=JavaScript>
<!--
newbie = new Image();
newbie.src="../img/newbie.gif";
guru = new Image();
guru.src="../img/guru.gif";
comm = new Image();
comm.src="../img/forum.gif";
about = new Image();
about.src="../img/about.gif";
-->
</script>

</head><body>
<table cellpadding=0 cellspacing=3 border=0 summary="макет страницы">
<tr valign=top><td><a href=../index.html><img src="../img/topbox.gif" alt="Остров пингвинов"></a></td>
<td height=60 bgcolor="#FFCC33"></td></tr>
<tr><td colspan=2><img src="../img/blue-line.gif" width=600 height=5
alt="- - - - - - - - - - - - - - - - - - - - - - -">
<tr valign=top><td width=131>
<img name="corner" src="../img/articles.gif" width=125 height=91 alt="Сольные выступления"><br><br>
<a href="../articles/newbie.html" onmouseover="document.corner.src='../img/newbie.gif';return true" onmouseout="document.corner.src='../img/articles.gif';return true">Для начинающих</a><br><br>
<a href="../articles/guru.html" onmouseover="document.corner.src='../img/guru.gif';return true" onmouseout="document.corner.src='../img/articles.gif';return true">Для знатоков</a><br><br>
<a href="../articles/community.html" onmouseover="document.corner.src='../img/forum.gif';return true" onmouseout="document.corner.src='../img/articles.gif';return true">Для души</a><br><br>
<a href="../articles/about.html" onmouseover="document.corner.src='../img/about.gif';return true" onmouseout="document.corner.src='../img/articles.gif';return true">О нас</a>
</td><td>

<p>
Данный курс расчитан на слушателей, знакомых с персональным компьютером
хотя бы на начальном уровне и желающих освоить новую Юникс-подобную систему. 
Во время занятий мы постараемся передать философию и основные приёмы работы,
отобранные в процессе эволюции вычислительной техники и программирования.
Различные версии Юникс в частности и технологии интернет вообще развиваются
чрезвычайно динамично, поэтому наша цель -- дать ориентиры и подготовить
слушателей для дальнейшей самостоятельной работы.
<ul><li><a href="#1">1. Юникс -- многопользовательская система</a>
  <li><a href="#2">2. Компьютер в сети</a>
  <li><a href="#3">3. Файловая система,стандарты,дистрибутивы</a>
  <li><a href="#4">4. Возможности shell</a>
  <li><a href="#5">5. Основы администрирования</a>
  </ul>

<h2><a name="1">1. Юникс -- многопользовательская система</a></h2>
   
Компьютер под управлением ОС Юникс позволяет работать в системе
одновременно многим пользователям, и каждому из них запускать много
задач. Для входа в систему в ответ на приглашение
<blockquote><pre>
имя_хоста login:
Password:
</pre></blockquote>
<p>
нужно ввести имя пользователя, и подтвердить его паролем.  Пользователь,
точнее бюджет пользователя (account), должны быть созданы заранее
администратором. Это имя видимо всем и к нему привязаны почтовый адрес,
домашний каталог и прочая персональная информация. Пароль, напротив,
не должен знать никто, кроме самого пользователя. Он является ключом к
вашему бюджету в этой системе, иногда и во всей сети. Пароль меняется
с помощью команды
<blockquote><pre>
приглашение $ passwd
</pre></blockquote>
<p>
Пароль нужно продумать заранее. Он должен быть как минимум из 6
символов, из смеси строчных, заглавных букв, цифр и прочих закавычек и
значков. Правильно настроенная система не позволит установить ни слабый
пароль, ни похожий на имя пользователя.  Помните, что ваш пароль не
должен знать никто, даже сисадмин, а украденный пароль является самым
первым шагом к компьютерным преступлениям.
<p>
Если вы успешно вошли в систему и получили приглашение командного
процессора, или <tt>shell</tt>'а, то теперь можете задавать команды и выполнять
программы. После выполнения любой программы вы снова возвратитесь в тот
же самый <tt>shell</tt>, и так много-много раз, пока не пожелаете закончить сеанс
работы и выйти из системы. Для выхода нужно набрать команду <tt>logout</tt> или
<tt>exit</tt>, а проще всего <tt>Ctrl-D</tt>
<p>
<tt>SHELL</tt> выполняет команды, вводимые пользователем, и выдаёт
результат.  Если происходит ошибка при вызове или выполнении программы,
вместо результата выдаётся сообщение об ошибке. Эти 3 потока называются
соответственно <tt>Std IN</tt>, <tt>Std OUT</tt>, <tt>Std ERR</tt>, или потоки с
номерами 0, 1, 2.  Обычно стандартный ввод принимается с клавиатуры, а
стандартный вывод и ошибки направляются на экран. Указанные потоки можно
или по отдельности, или вместе легко перенаправить либо в файл, либо на
вход следующей программы (конвейер, pipe), либо и в файл и в конвейер.
<p>
По умолчанию же ввод, вывод и ошибки привязаны соответственно к клаве,
экрану и экрану. Исторически все это называется tty, или консоль,
терминал. Вообще говоря, терминалом может быть всё, что угодно,
начиная с телетайпа (<tt>tty=tELEtyPE</tt>), или любая программа, эмулирующая
терминал.  KOI8-R, кодировка, используемая в Юникс, создана именно с
учетом многообразия терминалов, и позволяет читать русский текст на
любом терминале, передавая при необходимости русский текст методом
транслитерации.
<p>
На типичном компьютере IBM PC с обычной клавиатурой вы можете
переключаться между виртуальными консолями с помощью комбинации клавиш
Alt-F1...Alt-F12. В каждой из этих консолей, при настроеной программе
getty, вы можете войти в систему и получить <tt>shell</tt>.
<p>
Команды, позволяющие посмотреть персональную информацию и пообщаться с
другими пользователями, следующие:
<ul>
<li> id -- имя пользователя и группы, к которым он принадлежит.
     для системы важны только числовые id
<li> echo $TERM -- тип терминала
<li> set -- посмотреть или установить программное окружение 
<li> tty -- номер устройства консоли
<li> stty -- детальные настройки терминала
 
<li> w -- все пользователи и что они делают
<li> who -- список пользователей и их терминалы
<li> finger -- персональная информация о пользователях
<li> mail -- чтение и отправка почтовых сообщений
<li> write -- вывод на экран отдельному пользователю
<li> talk -- двустороннее общение, разговор
</ul>
<p>
Последние 2 программы работают только если пользователь не заблокировал
вывод на свой терминал. Запретить или разрешить вывод на экран можно
командой mesg. Если вы получили сообщение наподобие "<tt>write: user_name
has messages disabled</tt>", всегда можно отправить письмо и договориться о
сеансе разговора.
<p>
Программы <tt>w</tt>, <tt>who</tt>, <tt>write</tt> работают только в пределах
одного хоста (Юникс системы). Программы <tt>finger</tt>, <tt>mail</tt>,
<tt>talk</tt> могут обращаться к любому хосту в интернет, но только если в этой
системе настроены соответствующие сервисы.
<p>
Кроме средств общения и совместной работы пользователей,
многопользовательская система предусматривает и защиту юзеров и
их информации друг от друга. Защита пользователей и всей системы
осуществляется с помощью объединения пользователей в группы и
предоставления определенных прав этим группам или отдельным пользователям.
<p>
Каждый файл и каждый каталог в системе принадлежит одному пользователю
и одной группе. Если пользователь, обращающийся к данному объекту, не
является владельцем и не входит в группу-владельца объекта, то права
доступа определяются как "все остальные".  Для каждой из этих трех групп
- сам пользователь, группа-владелец и все остальные, в свою очередь,
определены 3 типа доступа.  Объект (файл, каталог, устройство) может быть
доступен для чтения, для записи и/или для исполнения. Посмотрите, как
выглядят права доступа и владельцы файлов (каталогов) на примере <tt>/home/</tt> :
<blockquote><pre>
... $ ls -l /home
-rw-r--r--    1 root   root      0 Мар 23 12:43 README
drwxr-xr-x    3 root   root   4096 Окт  9 21:15 ftp
drwxr-xr-x   36 ophil  staff  4096 Мар 23 09:50 ophil
drwxr-sr-x    9 proba  users  4096 Мар 21 13:36 proba
lrwxrwxrwx    1 root   root     11 Окт  9 21:14 www -&gt; ftp/pub/doc
</pre></blockquote>
<p>
Для изменения прав доступа к своим файлам и каталогам используются
следующие программы:
<ul>
<li> chmod -- изменение прав доступа к объекту
<li> chgrp -- изменить владельца-группу, только если вы входите в группу
<li> umask -- права доступа (числовое дополнение) ко вновь
	создаваемым файлам и каталогам
<li> ls    -- просмотр содержимого каталога, много опций
<li> stat  -- полная информация об объекте в файловой системе
</ul>
<p>
В Юниксе есть особый пользователь, <b>root</b>, или пользователь с
id=0, для которого не действуют никакие вышеупомянутые ограничения.
Если вы постоянно работаете под <b>root</b>'ом, ваша система постепенно
превратится в однопользовательскую персональную. Вы не будете чувствовать
ограничений, мешающим работе обычных юзеров. С другой стороны, если к
какому-то файлу доступ предоставлен по ошибке и нарушает защищенность
системы, вы этого тоже не заметите.  Первая заповедь сисадмина --
не работай из-под <b>root</b>'а.
<p>
Если файл является исполняемым, т.е. установлен бит исполнения,
<tt>x</tt> в правах доступа, и у вас есть право его выполнить, то вы можете
использовать этот файл как имя программы. Все команды, задаваемые
в командной строке или вызываемые из других программ, являются
такими исполняемыми файлами либо непосредственно встроены в <tt>shell</tt>.
<p>
Запущенный таким образом на выполнение файл образует в памяти
компьютера исполняемый процесс. Этот процесс наследует от запустившего
его пользователя права и среду выполнения (environment).
Кроме работы в нескольких консолях, можно также в каждой из
них запускать несколько задач (процессов). Для запуска задач
и управления ими используются следующие команды:
<ul>
<li> &amp; -- в конце команды, запустить программу как фоновый процесс.
	иногда полезно заранее перенаправить вывод в файл.
<li> jobs -- посмотреть список задач
<li> fg -- перевести процесс из фона в активный
<li> sleep -- ждать указанное время
<li> Ctrl-Z -- приостановить выполнение задачи
<li> kill --	послать сигнал процессу, завершить процесс
<li> nohup -- продолжать работу задачи после завершения сеанса юзера
<li> ps -- посмотреть список процессов в системе
<li> at -- запуск задачи в указанное время
<li> cron -- запуск задач по расписанию
</ul>
<p>
Подробнее о возможностях этих и других программ можно узнать из
интерактивной помощи, доступной при работе в системе Юникс.  В первую
очередь обратитесь к команде <tt>apropos</tt> с каким либо словом, относящимся
к вашей проблеме, например:
<blockquote><pre>
... $ apropos unix
</pre></blockquote>
<p>
Эта команда выдаёт список всех разделов руководства, содержащих в заголовке
указанное слово. Чтобы получить краткое описание всех имеющихся программ
и руководств, попробуйте вот это:
<blockquote><pre>
... $ apropos .|less
</pre></blockquote>
<p>
Первым словом в выводе <tt>apropos</tt> является название страницы руководства
(manual), подробно описывающим команду и все ее параметры. Т.н. страница
руководства может быть размером с хорошую книжку, но название раздел
принадлежит цифре в скобках, следующей за именем страницы. Чтобы посмотреть
список и назначение разделов руководства, воспользуйтесь командой
<blockquote><pre>
... $ man man
</pre></blockquote>
<p>
Еще одним обширным источником документации по установленным программам
является команда <tt>info</tt>. Эта программа предоставляет некоторые возможности
гипертекста: см. <tt>info info</tt>.
<p>
Просто <tt>help</tt> выдаёт краткую справку по <tt>shell</tt>.
<tt>Help имя_команды</tt> даст пояснение по встроеным в <tt>shell</tt>
командам и управляющим конструкциям. Полезные сведения можно отыскать
в документах серии HOWTO.
<p>
В бесчисленных мегабайтах документации, доступной он-лайн или в Сети, легко
заблудиться. Для самого общего представления знайте, что всю документацию
можно условно разбить на 3 уровня подробности и надежности.
<p>
Первый уровень предлагают статьи в стиле HOWTO и отдельные главы из
технических книг. Они описывают конкретную программу или проблему
и предлагают рецепты для ее решения. В качестве первого шага для
ознакомления с какой-то темой такие документы могут быть весьма полезны,
часть из них переведена на русский язык. С другой стороны, книги и
популярные статьи неизбежно носят общий характер и отстают по времени
от самых последних версий.
<p>
Второй уровень представляет собой техническая документация, содержащаяся
в страницах руководства, info-учебниках, в разных документах, включенных
в состав пакета и находящихся обычно в каталоге /usr/doc/имя_пакета
За качеством этих документов следят авторы и сопроводители пакета, как
правило, в них точно описаны все возможности программ.
<p>
Наконец, для доступных в исходных кодах программ, безусловно полную
и актуальную информацию можно извлечь из исходников программ, комментариев,
сопутствующих документов и примеров. Наличие исходного кода дает возможность
не только изучать программу, но при желании развивать ее дальше.
<p>
Не бойтесь экспериментировать и учитесь задавать вопросы компьютеру.
Только сама система знает ответы на все связанные с ней вопросы.
Для пытливого пользователя самым лучшим, живым учебником является
его компьютер
.
<h2><a name="2">2. Компьютер в сети</a></h2>
<p>
Известное утверждение "сеть -- это компьютер" как нельзя лучше подходит
к системе Юникс. Если для персональной системы разграничение прав
пользователей, существующее в многопользовательских ОС, может показаться
излишним, то при подключении компьютера к сети подобная защита оказывается
жизненно необходимой.  Сетевая технология с коммутацией пакетов под общим
названием TCP/IP реализована во многих современных операционных системах
и является основой глобальной сети Internet. Исторически и идейно эта
технология возникла и развивалась именно в системах Юникс. Первые версии
Юникс распространялись в исходниках, систему развивали и дорабатывали
сотни исследователей. Точно также создавались и развивались сервисы
будущей глобальной Сети.
<p>
Если ваш компьютер совершенно отрезан от сети -- нет ни модема, ни сетевой
карты, то и тогда есть специальный интерфейс lo (local loopback),
позволяющий работать всем сетевым программам. Чтобы действительно
соединить компьютеры между собой и пересылать между ними информацию,
необходимо физически связать компьютеры с помощью модема или сетевой
карты, а также включить поддержку устройства связи в ядро. Для подключения
сетевого интерфейса используется программа <tt>ifconfig</tt>. При запуске без
параметров эта команда покажет текущее состояние сетевых устройств:
<blockquote><pre>
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:3856  Metric:1
          RX packets:578 errors:0 dropped:0 overruns:0 frame:0
          TX packets:578 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
</pre></blockquote>
						   
Реальному интерфейсу будет соответствовать устройство ppp0 или sl0 для
модема, eth0, eth1 и т.д. для сетевых карт.
<p>
Базовым понятием технологии TCP/IP является IP-адресация. Каждый IP-пакет,
путешествующий в и-нете, обязательно имеет в заголовке адрес отправителя
и адрес получателя. IP-адрес представляет собой 32-разрядное двоичное
число, обычно обозначаемое четырьмя десятичными числами от 1 до 255,
разделенными точками, в примере выше -- 127.0.0.1
<p>
IP-адреса являются весьма ограниченным ресурсом и не могут назначаться
произвольно. Для правильной маршрутизации пакетов диапазоны IP-адресов
разбиваются на сети и подсети с помощью маски -- также 32-разрядного
числа, содержащего в левой части двоичные единички, а в правой части
некоторое количество двоичных нулей.  Свое название -- маска сети - это
число получило потому, что при наложении на IP-адрес единички покажут
номер сети, а остальная часть адреса будет номером хоста (компьютера)
в этой сети.
<p>
Прохождение пакета по лабиринту хостов к месту назначения определяется
таблицей маршрутов, ведущейся на каждом хосте. Эта таблица может быть
простейшей, состоящей из одного единственного адреса, задающего маршрут
по умолчанию. На узловых хостах глобальной сети, соединяющих между
собой много сетей, эта таблица может быть очень большой, динамически
изменяющейся с помощью специальных протоколов маршрутизации. Посмотреть
и изменить таблицу маршрутов можно с помощью команды route. А изучать
маршрут между двумя хостами или топологию сети удобно при помощи утилит
<tt>tracepath</tt> или <tt>traceroute</tt>. Для локальных сетей выделены
4 специальных диапазона адресов, которые можно свободно назначать
хостам внутри своей сети, но пакеты от них не должны выходить за пределы
локальной сети.  Пакеты с такими локальными адресами правильно настроеный
маршрутизатор должен сразу уничтожать.
<p>
Двоичные и десятичные IP-адреса удобны для компьютеров, но человеку
привычнее слова и имена. Для преобразования адресов в имена и наоборот
существует сервис DNS. В простейшем случае можно вести список хостов
в таблице /etc/hosts. Но уже для небольшой сети необходимо настроить
настоящий DNS-сервер. Одной из старейших и самых распространенных программ
для этого сервиса является <tt>bind</tt>. Порядок поиска по разным доменам
(сетям) и адрес DNS-сервера задается в файле /etc/resolv.conf
<p>
Имена доменов, в связи со стремительным ростом популярности Интернет,
стали выгодным товаром. Часто имя домена регистрируют впрок, на всякий
случай, или чтобы выгодно перепродать. Процедуру регистрации домена
можно пройти на специальных уполномоченных на это серверах, а посмотреть
принадлежность домена можно с помощью программы <tt>whois</tt>.
<p>
IP-адресация и еще несколько протоколов нижнего уровня являются базой
для следующего уровня -- TCP (Transmission Control Protocol). Вместе
они образуют т.н. стек протоколов TCP/IP. На этом уровне появляется
новое понятие -- порт TCP. В файле /etc/services номерам портов
приписываются названия сервисов, обслуживающих эти порты. И сами номера,
и названия сервисов, и их назначение и применение регламентированы особыми
документами -- RFC (Request For Comments).  Работа этих сервисов, точнее,
реализующих их программ, как раз и создает то богатство возможностей,
сделавших Интернет такой модной темой для далеких от компьютеров людей.
<p>
Но нас интересует именно техническая сторона, так что первым делом мы
познакомимся с программой <tt>nmap</tt>. Эта программа, наряду с прочим,
позволяет просканировать порты хоста и обнаружить работающие сервисы.
Обнаружив открытый (ожидающий запросы) порт, можно попытаться открыть
сессию (соединение) через этот порт. Самым простым инструментом для работы
с портом является программа <tt>telnet</tt>. Она позволяет работать в
<tt>shell</tt>, если он у вас есть, либо вести диалог с работающим сервисом. Для
защиты передаваемой информации можно использовать программу <tt>ssh</tt>,
обеспечивающую шифрование данных.
<p>
Конечно, для работы с тем или иным сервисом удобнее использовать
специально созданные для этого клиенты. Например, для передачи файлов
по протоколу FTP, существуют несколько клиентов: <tt>ftp</tt>, <tt>lftp</tt>,
<tt>ncftp</tt>.  Упомянутая в первой части программа <tt>mail</tt> отравки и
чтения почты пример использования почтового сервиса -- SMTP. Клиентские
программы для работы с почтой составляют класс программ MUA (Mail User
Agent): <tt>mutt</tt>, <tt>pine</tt>. К ним же можно отнести и особую программу
<tt>procmail</tt>, предоставляющую возможность запрограммировать обработку
приходящей почты.
<p>
Еще один сервис и соответствующий класс клиентов предоставляют возможность
отправлять сообщения не персонально получателям, а публиковать их для
всех желающих в т.н. группах новостей, или news'ах, а соответствующий
протокол называется NNTP. Этот сервис подразумевает включение хоста во
всемирную сеть подобных серверов и рассылку между ними каждого нового
сообщения. Типичными клиентами для чтения news'ов являются <tt>nn</tt>,
<tt>slrn</tt>, <tt>emacs</tt> с соответствующими надстройками.
<p>
Важным моментом при обмене сообщениями является защита содержимого
ваших писем и подтверждение подлинности отправителя. Эту сложную задачу
позволяет решить система несимметричного шифрования с открытым ключом.
Первой программой этого класса стала скандально известная программа PGP,
опубликованная в Интернет Филиппом Циммерманом. Сейчас становится новым
открытым стандартом OpenPGP (RFC2440) и реализующий незапатентованные его
части проект GnuPG (GNU Privacy Guard). При настройке клиентских программ
почты и новостей для совместной работы с <tt>gpg</tt> можно создать надежно
защищенную систему коммуникаций, доступную ранее только при использовании
закрытых хорошо охраняемых каналов
.
<h2><a name="3">3. Файловая система,стандарты,дистрибутивы</a></h2>
<p>
В системе Юникс есть еще одно весьма важное отличие от персональных
систем. Структура каталогов в файловой системе довольно строго
регламентирована, большинство файлов общего пользования обычно имеют
вполне определенное место в дереве каталогов. Это дерево растет корнем
кверху и имеет приблизительно такую структуру:
<ul>
<li>корень дерева каталогов
  <ul>
    <li> bin - исполняемые файлы, минимум для старта системы 
    <li> boot - образы ядра, загрузчики
    <li> dev - устройства, отображение физ. уст-в в ядро
    <li> etc - файлы конфигурации, настройки
    <li> home + - домашние (персональные) каталоги пользователей
    	<ul>
	  <li> ftp - файловый архив для анонимного ftp
	  <li> ophil - пользователь
	  <li> proba - пользователь
	  <li> www - корневой для HTTP сервера
	</ul>
    <li> lib + - основные разделяемые библиотеки, libc
    	<ul>
	  <li> modules - загружаемые модули ядра	
	  <li> security - pam-библиотечные модули
	</ul>
    <li> lost+found - каталог для потеряных кластеров ext2fs
    <li> mnt - точки монтирования дополнительных фс(файловых систем)
    <li> proc - псевдо-фс, интерфейс к данным в ядре 
    <li> root - домашний каталог пользователя 0 --- root'а
    <li> sbin - исполняемые файлы для root'а, минимальный набор 
    <li> tmp - только для временных файлов, постоянно чистится
    <li> usr +	- основной каталог для системных файлов
    	<ul>
	  <li> X11R6 - поддерево каталогов системы Xwindows
	  <li> bin -
	  <li> doc - подробная документация, копирайты для каждой
			  програмы
	  <li> games - игры
	  <li> include	- заголовки (header) для программ на языке C
	  <li> info - он-лайновые книги в формате info
	  <li> lib - 
	  <li> local - специфические местные каталоги
	  <li> man - он-лайновые руководства, помощь
	  <li> sbin -
	  <li> share - общий разделяемый между программами
	  <li> src - исходные коды ядра
	</ul>
    <li> var +	- часто изменяемые, временные системные файлы
    	<ul>
	  <li> backups	- запасные копии
	  <li> cache - сохраненные данные программ
	  <li> lib -
	  <li> local -
	  <li> lock - файлы блокировки
	  <li> log - журналы, диагностика, системные сообщения
	  <li> mail - входящая почта пользователей
	  <li> quota - ограничения (квоты) на дисковое пространство
	  <li> run - PID запущенных задач
	  <li> spool - очереди, списки, временные файлы
	  <li> state - состояние, сообщения отдельных программ
	  <li> tmp -
	</ul>
  </ul>
</ul>
<p>
Это только основные каталоги. Обычно каталоги lib, include, а также
подражающая им иерархия X11R6, разбиваются на дополнительные каталоги,
отражающие названия программ или сервисов.  Приблизительно так выглядит
смонтированная файловая система. Чтобы ее создать, необходимо вспомнить
опыт разбиения диска на разделы, а также узнать новое понятие монтирования
устройств.
<p>
Программа fdisk по своему назначению и возможностям похожа на одноименные
программы из других ОС. Более того, <tt>fdisk</tt> от Линукс, например,
понимает разбиение диска на разделы, сделанные в других ОС. Если ваш диск
уже разбит на разделы, следующая задача создать на нём файловую систему.
В этом месте уже возникают отличия между разными вариантами Юникс,
мы будем рассматривать далее версию Linux 2.4. Последняя версия этой
ОС поддерживает почти все известные файловые системы, а на нескольких
самых новых (reiserfs, ext3, jfs, xfs) имеется возможность журналирования
всех записей на диск. Для начала, однако, потренируемся на традиционной
старомодной ext2.
<p>
В простейшем случае, чтобы создать файловую систему на вновь созданном
разделе, например на /dev/hda3, нужно выполнить команду:
<blockquote><pre>
... # mke2fs /dev/hda3
</pre></blockquote>
<p>
Более точные настройки можно сделать с помощью многочисленных параметров,
передаваемых программе, либо впоследствии с помощью программы <tt>tune2fs</tt>.  Эта программа принимает почти все параметры, имеющиеся в <tt>mke2fs</tt>, и позволяет настраивать ext2 без разрушения имеющихся данных.
<p>
Для доступа к дисковому устройству и имеющемся на нём файловой системе ее
необходимо примонтировать к существующей ФС, как правило, в специально
предназначенный для этого каталог /mnt. Чтобы смонтировать устройство,
ядро должно включать драйвер этого устройства, в самом ядре или в
виде загружаемого модуля. Также должна поддерживаться файловая система,
установленная на этом устройстве. Если это выполнено, процесс монтирования
сводится к выполнению команды
<blockquote><pre>
... # mount [-t тип_фс] [-o опции] /dev/устройство точка_монтирования
</pre></blockquote>
<p>
Автоматизировать процесс монтирования дополнительных устройств
можно несколькими способами. Первый способ -- включить устройств
в файл /etc/fstab.  Этот файл, как минимум, должен содержать строки
для псевдо-фс proc, устройство откачки (свопа) памяти, и устройство с
корневой файловой системой.
<blockquote><pre>
proc		/proc		proc	defaults
/dev/hda2	none		swap	sw
/dev/hda3	/		ext2	defaults,nocheck 0 1
/dev/hda4	/mnt/hda4	ext2	defaults,nocheck,auto 0 1
/dev/hda1 /mnt/vfat vfat defaults,noauto,user,codepage=866
,iocharset=koi8-r 0 0
/dev/cdrom	/mnt/cdrom	iso9660	defaults,noauto,user 0 0
</pre></blockquote>
<p>
Второй способ -- включить в ядро или использовать дополнительные
пользовательские программы для автоматического монтирования устройства
при обращении к нему.
<p>
Для работы с дискетами, отформатированных в их родной файловой системе
fat, включая и более современную vfat, хорошо подходит набор программ под
названием mtools. В этот набор входят многие знакомые нам со времен ДОС
команды: <tt>copy</tt>, <tt>del</tt>, <tt>dir</tt>, <tt>format</tt>, <tt>label</tt>,
<tt>deltree</tt>, <tt>type</tt> и другие.  Не забывайте только подставлять
перед каждой из этих команд букву m.  С помощью <tt>mtools</tt> можно,
как в ДОС, обращаться к дискетам под именем буквы и двоеточия:
<blockquote><pre>
... $ mdir a:
... $ mcopy b: .
... $ mformat a:
</pre></blockquote>
<p>
Быстро отыскать нужный файл в системе помогает специальная программа
locate, ведущую базу данных всех доступных файлов в системе и регулярно
обновляющую этот список файлов. Для первоначального знакомства с изобилием
файлов в новой системе, а также для простых операций с файлами, можно
воспользоваться программой <tt>mc</tt> (Midnight Commander), программой в
стиле старого знакомого по ДОС -- Norton Commander'а.
<p>
Два особых каталога в корневой файловой системе: /dev/ и /proc/.  Их
особенность в том, что они содержат не обычные каталоги, а псевдо-файлы,
обеспечивающие интерфейс к устройствам и структурам данных в ядре,
интерфейс, напоминающий работу с обычными файлами. Например:
<blockquote><pre>
... $ dd &lt; /boot/vmlinuz-2.4.5 &gt; /dev/fd0
</pre></blockquote>
<p>
копирует поблочно, в обход файловой системы, файл на дискету. Так, кстати,
создается загружаемая дискета Линукс.
<blockquote><pre>
... $ cat /proc/meminfo
</pre></blockquote>
<p>
Эта команда покажет всю информацию о памяти, используемой ядром памяти
в данный момент.  Используя этот простой способ -- структура данных
ядра как псевдо-файл, можно также изменять настройки ядра в процессе
работы. Например, для включения форварда на компьютере-шлюзе нужно
сделать:
<blockquote><pre>
... # echo "1" &gt; /proc/sys/net/ipv4/ip_forward
</pre></blockquote>
<p>
Мы уже упоминали некоторые атрибуты файлов и способы их просмотра
с помощью программ <tt>ls</tt> или <tt>stat</tt>. Одной из характеристик
файла является количество ссылок к содержимому файла, т.е. к множеству
хранимых на диске блоков, к которому мы обращаемся под именем этого файла.
У обычного (regular) файла может быть несколько совершенно равноправных
имен, адресующих одно и то же множество блоков. Эти имена называются
жесткими (hard) ссылками, а дополнительные имена создаются с помощью
команды <tt>ln</tt>. Эта же команда позволяет создавать другой тип ссылок -
символические (symbolic) ссылки. Символические ссылки обладают большей
гибкостью, могут указывать на любой тип файла, на любом устройстве,
в любой файловой системе.
<p>
Раз уж мы упомянули о разных типах файлов, то нужно сказать и о программке
под именем <tt>file</tt>, знающей обо всех известных типах файлов и умеющей
также определять тип его содержимого.
<p>
Семейство операционных систем под зарегестрированным торговым
знаком Unix(TM), объединяет гораздо больше, чем следование правилам
при размещении системных файлов и утилит. Вскоре после отпочкования
коммерческих версий Юникс от первоначального варианта фирмы ATT, стали
делаться попытки обеспечить переносимость программ их одной ОС в другие.
Наиболее важным стандартом, соблюдаемым всеми вариантами Юникс и другими
ОС, стал набор стандартов POSIX.
<p>
В последние годы, используя новые возможности, предоставляемые глобальной
сетью, огромную популярность получили свободно распространяемые варианты
Юникс, в первую очередь Linux и FreeBSD.  Эти ОС представляют собой
полностью переписаные наново, доступные вместе со своим исходным кодом
системы. Кроме разных реализаций системных вызовов (API), эти системы
отличаются также лицензией, по которой происходит распространение и
развитие этих ОС. Для FreeBSD это лицензия BSD, налагающая очень мало
обязательств на пользователя и разработчика.  Линукс же является частью
грандиозного проекта ГНЮ (ГНЮ Не Юникс), поставившего своей целью создание
всех необходимых программ и юридической гарантии, что эти программы
останутся открытыми и доступными навсегда. Проект ГНЮ и метод открытой
разработки привлек удивительно много программистов и исследователей,
так что свободные программы оказывают заметное влияние на сложившийся
рынок коммерческого ПО.
<p>
Доступные в исходных кодах программы можно настроить для работы в
очень многих системах. В Юникс стандартизованы не только внутренние
системные вызовы, но и многие инструментальные средства, компиляторы,
языки программирования, доступные в том числе и в персональных системах.
Но всё же большим шагом в облегчении работы с системой стало появление
дистрибутивов. Дистрибутив использует понятие пакета, специально
подготовленного набора файлов и скриптов для его установки и настройки.
Широко известен формат пакетов <tt>rpm</tt>, используемый в дистрибутиве
Линукс от Red Hat, Mandrake, русскоязычном AltLinux и многих других. Еще
один формат пакета и соответствующую программу-установщик создали в
проекте Дебьян.
<p>
Среди многочисленных дистрибутивов также стали возникать отличия при
размещении файлов в иерархии каталогов. Выработкой стандарта в этой
области занимается Free Standards Group. Уже выработаны рекомендации
FHS (Filesystem Hierarchy Standard), а конечной целью является создание
исчерпывающего набора спецификаций LSB (Linux Standard Base).
<p>
Познакомимся немного подробнее с дистрибутивом Дебьян. Он предоставляет
ряд уникальных возможностей, выделяющий его из огромного числа доступных.
Дебьян является официальным дистрибутивом фонда FSF и проводит политику
на популяризацию свободного ПО. Развитие дистрибутива Дебьян происходит
распределенно, через и-нет, в нём участвуют свыше 700 разработчиков
со всего мира. С 1993 года этот дистрибутив вырос до 7000+ пакетов,
создана разветвленная сеть ftp-архивов и уникальная система дебианизации и
сопровождения программ. Дебьян по праву считается одним из самых надёжных
и отлаженных, а появившаяся недавно тестовая версия, промежуточная между
стабильной и экспериментальной, дает возможность иметь самые свежие
версии программ без риска нарушить стабильность системы.
<p>
Для работы с пакетами программ используется программа <tt>dpkg</tt>
и специально созданный формат пакета <tt>.deb</tt>. Установщик <tt>dpkg</tt>
отслеживает зависимости пакетов друг от друга, выполняет все предписанные
процедуры при установке и удалении программ. Над <tt>dpkg</tt> существуют
несколько программ, облегчающих выбор и установку множества пакетов. Это
в первую очередь <tt>dselect</tt> и <tt>apt</tt>.  Можно также использовать
пакеты с префиксом task-, являющимися псевдо-пакетами, содержащими
список необходимых пакетов для выполнения компьютером определенного
вида работ. Например, чтобы превратить вашу систему, наряду с прочим,
в инструмент программиста-разработчика, нужно выполнить нечто наподобие:
<blockquote><pre>
... # apt-get install task-с-dev task-debian-devel
</pre></blockquote>
<p>
Если вы установили набор программ для разработчика, включая компилятор,
заголовки различных библиотек, необходимые инструменты и скрипты, то
вы сможете по достоинству оценить имеющиеся средства разработки.
<p>
Исходные коды, составляющие дистрибутив, хранятся в виде 3 файлов -
оригинальный архивный файл от авторов программы, файл изменений,
сделанный сопроводителем при встраивании этой программы в Дебьян,
а третий маленький файлик с расширением <tt>.dsc</tt> -- служебная информация,
контрольные суммы вышеназванных файлов и подпись сопроводителя.
Для программ, созданных специально для Дебьян, файла изменений нет.
<p>
Исходники распаковываются, проверяется целостность пакета и налагаются
необходимые правки (патчи) с помощью одной команды:
<blockquote><pre>
... $ dpkg-source -x название-пакета_версия.dsc
</pre></blockquote>
<p>
Можно теперь смотреть и править исходники пакета. Основным,
т.н. make-файлом для сборки пакета, является файл debian/rules .
Чтобы собрать пакет из исходников, достаточно одной команды, например:
<blockquote><pre>
... $ debuild -b -uc 2&gt;&amp;1|tee build-log
... $ fakeroot debian/rules clean
</pre></blockquote>
<p>
Вторая команда необязательна -- она очищает каталоги от временных
и производных файлов.
<p>
Мы познакомились со средствами разработчика уже на начальном этапе
знакомства с системой по нескольким причинам. Во-первых, наличие
исходников является уникальной особенностью изучаемого нами предмета, а
также гарантией отсутствия замаскированных дыр в программе. Во-вторых, как
мы увидели, сборка пакетов из исходников выполняется простыми командами,
а исполняемые файлы и сам пакет создаются на мощном компьютере легко
и быстро.  Наконец, само получение и сопровождение отдельных пакетов
становится проще, если настроить средства разработки и работать с
исходниками
.
<h2><a name="4">4. Возможности shell</a></h2>
<p>
Командный процессор shell незримо сопровождает нас с первой секунды,
как только мы прошли процедуру регистрации в системе. Shell обладает
возможностями настоящего языка программирования, а также является гибко
настраиваемой удобной оболочкой для интерактивной работы, для связывания
воедино многочисленных программ и утилит.
<p>
Рассмотрим вначале, как можно настроить свой <tt>shell</tt> по собственному
вкусу.  По умолчанию вашим <tt>shell</tt>, скорее всего, будет командный
процессор <tt>bash</tt>.  При инициализации <tt>bash</tt> вызываются и
последовательно выполняются несколько файлов:
<ul>
<li> /etc/profile -- общесистемный файл, для всех пользователей
<li> ~/.bash_profile -- при входе в систему, т.н. login-shell
<li> ~/.bash_login -- то же самое
<li> ~/.profile -- то же самое
<li> ~/.bashrc	-- в остальных случаях
</ul>
<p>
Чтобы не запутаться, помещайте все свои настройки в последний файл,
а затем вызывайте его из ~/.bash_profile . При необходимости, просто
добавьте или переопределите команды, выполняемые исключительно при входе
в систему. При выходе из login-shell исполняется файл ~/.bash_logout .
<p>
Большую часть команд в типичном стартовом скрипте (profile) занимает
определение переменных окружения, т.н. environment . Эти переменные затем
передаются в каждый вызываемый процесс и сопровождают пользователя до
его выхода из системы. Использовать эти переменные очень просто:
<blockquote><pre>
... $ HELLO="привет всем от $USER'а";export HELLO
... $ echo $HELLO|mail proba -s "$HELLO"
</pre></blockquote>
<p>
Список переменных, однако, может быть большим, имена многих из них
стандартизованы. Список всех переменных <tt>shell</tt> можно посмотреть
с помощью команды <tt>set</tt> без параметров. Команда <tt>env</tt>, или
<tt>printenv</tt>, выдаст список поменьше, доступных только в вызываемых
процессах.
<p>
Воспользуемся глобальными переменными, чтобы настроить т.н. <tt>locale</tt>,
определяющие язык и другие локальные для страны обозначения: время, дата,
денежная единица, форматный вывод чисел. Например, в общесистемном файле
/etc/profile могут быть определены такие переменные:
<blockquote><pre>
LANG=ru_RU.KOI8-R
LANGUAGE=ru_RU.KOI8-R
LC_ALL=ru_RU.KOI8-R
export LANG LANGUAGE LC_ALL
</pre></blockquote>
<p>
Допустим, вы захотели показывать даты и десятичные числа в международном
стандарте POSIX. Поэтому для собственного окружения, например в файле
~/.bashrc , переопределим глобальную переменную LC_ALL и зададим
новые:
<blockquote><pre>
LC_ALL=""
LC_NUMERIC=POSIX
LC_TIME=POSIX
export LC_NUMERIC LC_TIME
</pre></blockquote>
<p>
Все переменные, задающие локальную для страны информацию, имеют префикс
LC_.  Для просмотра текущих или всех доступных настроек используется
команда <tt>locale</tt>.  Вся связанная с <tt>locale</tt> информация хранится
в каталоге /usr/share/locale/.
<p>
Для комфортной работы из командной строки обязательно нужно знать о
следующих возможностях <tt>shell</tt>: история командш (<tt>history</tt>),
завершение ввода имени команды или файла, создание псевдонимов (<tt>alias</tt>). Перемещение по списку выполненных команд выполняется стрелками
вверх/вниз, а завершение ввода (completion) клавишей Tab. Если вы
обнаружили, что часто набираете какую-то команду, можно создать для этой
команды короткий <tt>alias</tt>, например:
<blockquote><pre>
... $ alias ll='/bin/ls -lF --color'
</pre></blockquote>
<p>
Можно также вставить определение <tt>alias</tt>'ов в файл ~/.bashrc
<p>
Посмотреть список встроенных в <tt>bash</tt> команд и версию вашего
<tt>shell</tt> можно просто набрав <tt>help</tt>. Таких команд довольно много,
включая и конструкции для написания сложных программ. Все они детально
описаны в имеющейся странице руководства <tt>man</tt>, общим размером около
90 обычных страниц.  Кратко прокомментирую главы из <tt>man bash</tt>.
<ul>
<li> OPTIONS -- список опций при вызове процессора
<li> ARGUMENTS -- оставшиеся после опций параметры
<li> INVOCATION -- порядок просмотра файлов инициализации
<li> DEFINITIONS -- определения, ипользуемые дальше в руководстве
<li> RESERVED WORDS -- зарезервированые слова, используемые в языковых
		конструкциях, при написании скриптов
<li> SHELL GRAMMAR -- описание синтаксиса и семантики команд
	<ul>
	<li> Simple Commands -- определение простой команды
	<li> Pipelines -- определение конвейера команд
	<li> Lists -- определение списка команд
	<li> Compound Commands -- определение составной команды,
		составление команд, управляющие конструкции
	</ul>
<li> COMMENTS -- комментарии в программах
<li> QUOTING -- экранирование и интерпретация специальных символов
<li> PARAMETERS -- определение и типы параметров
	<ul>
	<li> Positional Parameters -- позиционные параметры,
				числа в соответствии с позицией при вызове
	<li> Special Parameters -- специальные параметры: $*, $@, $#, $?, $- ... 
	<li> Shell Variables -- список глобальных переменных, встроенных в shell
	<li> Arrays -- массивы
	</ul>
<li> EXPANSION -- ключевое понятие --- интерпретация полученной командной строки,
		подстановка значений спецсимолов, сравнение с шаблонами.
		Всего 7 типов расширения (интерпретации) параметров
		и их порядок.
	<ul>
	<li> Brace Expansion -- раскрытие фигурных скобок, генерация списков
	<li> Tilde Expansion -- подстановка домашнего каталога вместо ~
	<li> Parameter Expansion -- интерпретация и подстановка параметров
	<li> Command Substitution -- подстановка результата выполнения команды
				как новой команды
	<li> Arithmetic Expansion -- выполнение арифметических операций
	<li> Process Substitution -- перенаправление ввода-вывода
		для именованных конвейеров, если поддерживаются системой
	<li> Word Splitting -- разбиение строки параметров на слова
	<li> Pathname Expansion -- интерпретация спец. символов * ? ( [
			подстановка путей и имен, соответствующих шаблону,
			использование шаблонов, классы символов
	<li> Quote Removal -- удаление кавычек и символа экранирования "{ }"
	</ul>
<li> REDIRECTION -- перенаправления ввода вывода
	<ul>
	<li> Redirecting Input -- перенаправление ввода [n]<имя_файла
	<li> Redirecting Output -- перенаправление вывода [n]>имя_файла
	<li> Appending Redirected Output -- перенаправление вывода
					и добавление к файлу
	<li> Redirecting Standard Output and Standard Error -- объединение
			стандартного вывода и сообщений об ошибках
	<li> Here Documents -- способ помещения ввода непосредственно в скрипт
	<li> Duplicating File Descriptors -- создание дополнительных потоков
	<li> Opening File Descriptors for Reading and Writing -- открытие файла
	</ul>
<li> ALIASES -- создание псевдонимов команд
<li> FUNCTIONS -- определение функций
<li> ARITHMETIC EVALUATION -- использование арифметики в выражениях
<li> CONDITIONAL EXPRESSIONS -- условные выражения, проверки файлов и строк
<li> SIMPLE COMMAND EXPANSION -- подготовка команды к исполнению
<li> COMMAND EXECUTION -- порядок выполнения команды
<li> COMMAND EXECUTION ENVIRONMENT -- наследование переменных окружения
<li> ENVIRONMENT -- описание переменных окружения
<li> EXIT STATUS -- статус, возвращаемый результат выполнения команды
<li> SIGNALS -- сигналы и их обработка
<li> JOB CONTROL -- фоновые процессы и управлении ими
<li> PROMPTING -- настройка приглашения
<li> READLINE -- возможности редактирования и ввода в командной строке
<li> HISTORY -- история команд
<li> HISTORY EXPANSION -- вызов предыдущих команд
<li> SHELL BUILTIN COMMANDS -- список и параметры всех встроеных команд
<li> RESTRICTED SHELL -- ограниченный shell, только в заданном каталоге
</ul>
<p>
Как мы видим, руководство по <tt>bash</tt> предоставляет исчерпывающую
информацию по всем командам. Первым шагом к освоению <tt>shell</tt> должно
стать умение читать программы на этом языке, коих в системе довольно
много.  Для полноценного использования необходимо также знакомство с
обязательными в каждой Юникс системе наборами программ под названием <b>textutils</b> и <b>findutils</b>, а также с утилитами: сканером <tt>grep</tt>,
потоковым редактором <tt>sed</tt>, языком запросов <tt>awk</tt> и некоторыми
другими жемчужинами из классического наследия. Для этих многочисленных
инструментов <tt>shell</tt> выполняет роль связующего звена, соединяющего
воедино отдельные программы
.
<h2><a name="5">5. Основы администрирования</a></h2>
<p>
Итак, вы уже знаете о разграничении прав в многопользовательской
системе Юникс, о соединении компьютеров в сеть и семействе протоколов
TCP/IP, об основном инструменте пользователя -- командном процессоре,
о многочисленных программах и утилитах. Следующая наша тема --
администрирование пользователей и сервисов, установка и сопровождение
новых программ.
<p>
Для задач администратора придется время от времени пользоваться правами
суперпользователя под uid=0, или <b>root</b>'а. Чтобы получить эти права,
нужно, прежде всего, знать пароль. В некоторых организациях применяют
следующую практику в отношении рутового пароля. Минимум персонала,
только люди, отвечающие за работу сервера, создают и запоминают сложный
непредсказуемый пароль. Кроме этого, пароль запечатывают в конверт и
закрывают в сейфе у самого большого босса, как поступили бы с ключом от
всей компьютерной сети.
<p>
Программа <tt>su</tt> позволяет, зная пароль, войти в систему под любым
пользователем, в том числе и под <b>root</b>'ом. Более удобна, однако,
программа <tt>sudo</tt>. Эту программу можно настроить так, чтобы отдельные
пользователи могли запускать определенные административные приложения.
При этом им не нужно знать пароль рута, а все их действия записываются
в системных журналах.
<p>
Например, можно разрешить пользователю operator создавать, удалять и
изменять информацию пользователей в системе. Это значит указать в файле
/etc/sudoers для юзера operator разрешение на выполнение следующих
программ: <tt>useradd</tt>, <tt>userdel</tt>, <tt>usermod</tt>. Более точно
синтаксис этого файла и примеры использования приведены на странице
руководства <tt>man sudoers</tt>.
<p>
Доступ к файлам и устройствам регулируется назначением этим объектам
группы-владельца и объединения пользователей в группы. Список групп
пользователей ведется в файле /etc/group, а в файле /etc/passwd
указывается gid -- номер основной группы данного пользователя, или
группы по умолчанию.
<p>
К сожалению, мы живем в далеком от идеала мире, и в нашу простую и
стройную систему разграничения прав пользователей придется ввести
некоторые сложности, добавленные в систему Юникс позднее, как способ
борьбы с преступными наклонностями некоторых пользователей.  Когда-то
давно зашифрованые пароли пользователей хранили в том же файле /etc/passwd
и разрешали смотреть этот файл всем желающим.  Затем, однако, пришлось
создать дополнительную систему защиты, т.н.  "<b>shadow suit</b>", чтобы
стало сложнее украсть файл паролей.  Кроме этого, в файле /etc/shadow
хранится дополнительная информация, например, о сроке действия пароля.
<p>
Еще одна обязательная сегодня мера защиты системы -- установка лимитов
на ресурсы системы. В первую очередь это лимит на дисковое пространство,
которое может занять пользователь. Для этого используется набор программ
под общим именем <b>quota</b>. Кроме этого, необходима поддержка квот в
ядре Линукс.
<p>
Попробуем собрать ядро Линукс с поддержкой упомянутой квоты, и, возможно,
других особенностей вашего конкретного компьютера. Прежде всего,
раздобудем свежую стабильную версию ядра. Хотя ядро, входящее в состав
дистрибутива, может быть вполне работоспособным, нужно обязательно уметь
собирать ядро самостоятельно. Только в этом случае вы по-настоящему
используете и возможности вашего компьютера, и уникальную систему
разработки и отладки Линукс, созданную всемирным сетевым сообществом.
<p>
Основным архивом проекта Linux является сайт <a href="ftp://ftp.kernel.org">ftp://ftp.kernel.org</a>
или <a href="http://www.kernel.org">http://www.kernel.org</a>. Можно воспользоваться и обширной сетью зеркал этих
серверов. Затем нужно разархивировать полученый файл linux-2.4.0.tar.bz2,
и, при необходимости, наложить патчи. Патч (<tt>patch</tt>) представляет
собой один файл, содержащий необходимые изменения, чтобы получить из одной
версии программы другую. Для наложения патчей используется одноименная
программа <tt>patch</tt>. Процедура компиляции ядра подробно рассказана в
документации, содержащейся в исходниках.  Вкратце, последовательность
действий такова:
<blockquote><pre>
... # cd /usr/src/linux
... # make menuconfig
... # make dep 
... # make bzImage 
... # make modules 
... # make modules_install
</pre></blockquote>
<p>
Таким образом мы создали исполняемый образ ядра, включающий код для
распаковки сжатого ядра и загрузки его в память компьютера, а также
подготовили необходмые подгружаемые модули.  Теперь нужно попробовать
загрузить новое ядро с дискеты, и если всё в порядке, прописать новую
версию ядра в системный загрузчик, например, в <tt>lilo</tt> (liNUX loADER).
<blockquote><pre>
... # dd &lt;/usr/src/linux/arch/i386/bzImage &gt;/dev/fd0
... # cp /usr/src/linux/arch/i386/bzImage /boot/vmlinuz-2.4.3
... # cd /etc;cat &gt;&gt; lilo.conf
image=/boot/vmlinuz-2.4.3
label=new
root=/dev/hda3
read-only
^D
... # lilo
</pre></blockquote>
<p>
Процесс загрузки Юникс и многочисленных сервисов значительно сложнее,
чем это происходит в персональной системе. Процессом загрузки управляет
особая программа <tt>init</tt>, имеющая в системе всегда pid=1. В процессе
загрузки <tt>init</tt> переключается между несколькими уровня исполнения,
выполняя на каждом уровне набор сценариев. Сами сценарии для запуска и
останова каждого из сервисов хранятся обычно в каталоге /etc/init.d. Во
многих современных версиях Юникс используются идеи, первоначально
реализованные в системе Unix System V.  Файл конфигурации /etc/inittab
содержит описание уровней исполнения и вызов необходимых скриптов. Затем,
при переходе с уровня на уровень, особый скрипт /etc/init.d/rc, определяет
список и очередность запускаемых скриптов из каталога /etc/init.d/.
Более старая версия /etc/init.d/rc использует для этого специальные
каталоги /etc/rc.d/rc{0,1,2,3,4,5,6}.d/, содержащие символические
линки на сами скрипты, с префиксом типа SNNимя_скрипта для старта,
или префиксом типа KNNимя_скрипта для останова сервиса. Двузначное
число NN задает очередность запуска сервисов. Немного усложнив скрипт
/etc/init.d/rc, можно избавиться от необходимости следить за десятками
линков в семи каталогах. Это сделано в пакете <b>file-rc</b>, входящем в
дистрибутив Debian. Ту же задачу, которую ранее выполняли многочисленные
ссылки в нескольких каталогах, теперь выполняет единственный файл
/etc/runlevel.conf
<p>
Одним из важных сервисов, обязательных в каждой Юникс-системе, является
запускаемый в числе первых демон (daemon) <tt>syslogd</tt>. Демоном
называется программа, которая сразу после запуска отключает себя от
управляющего терминала и работает далее как фоновый процесс. В частности,
демон <tt>syslogd</tt> следит за ведением системных журналов. Этот сервис
предоставляет другим демонам возможность пользоваться стандартными
функциями для записи сообщений от различных системных программ. Как
обычно, настройки этого сервиса содержатся в файле /etc/syslog.conf,
а сами журналы ведутся в каталоге /var/log/.
<p>
Теперь, представляя в общих чертах свою цель -- базовую Линукс-систему,
плюс обязательные, плюс дополнительные сервисы по мере необходимости -
можно приступать к установке и настройке сервера с нуля, из дистрибутива.
<p>
Для любого дистрибутива сначала нужно загрузить сам Линукс, хотя бы в
самой минимальной конфигурации. Это можно сделать либо с CD-ROM'а, либо
с дискеты.  Существует также программа <tt>loadlin</tt>, позволяющая загрузить
ядро Линукс из многих версий ДОС. Кроме самого ядра, обычно создается
ramdisk -- образ файловой системы в оперативной памяти.
<p>
Далее процедура установки выполняется под управлением специальной
программы.  Некоторые программы предельно упрощают этот процесс, требуют
минимального вмешательства оператора. Мы, однако, пройдем процесс
инсталяции системы на примере дистрибутива Дебьян. Программа установки
Дебьян не использует графику на ранних этапах, менее требовательна к
ресурсам, и позволяет провести инсталяцию базовой системы только с дискет.
</td></tr><tr><td colspan=2 align=center>
<img src=../img/footer.gif border=0 usemap=#gulag alt="Олег Филон, Дм. Федорович, Ал-др Качанов">
<map name=gulag>
<area shape="rect" coords="0,10,130,25" href=../articles/articles.html alt="Статьи Олега Филона" title=ophil>
<area shape="rect" coords="0,25,51,37" href=../articles/articles.html alt="Статьи Олега Филона" title=ophil>
<area shape="rect" coords="140,25,317,40" href=http://www.stihi.ru/avtor/fedorovich alt="Литературная страница Дм. Федоровича" title=df>
<area shape="rect" coords="60,40,317,55" href=http://www.stihi.ru/avtor/fedorovich alt="Литературная страница Дм. Федоровича" title=df>
<area shape="rect" coords="290,5,440,20" href=http://www.webmascon.com alt="дизайн А. Качанова" title=community>
<area shape="rect" coords="343,20,440,38" href=http://www.webmascon.com alt="дизайн А. Качанова" title=community>
<area shape="default" href=../articles/articles.html alt="Статьи Олега Филона" title=ophil>
</map></td></tr>
</table>
</body>
</html>

