Title: Генерация случайного телефонного справочника
Description-ru: Генерация случайного телефонного справочника на языке AWK для использования в MySQL. Микрохаки Олега П. Филона, группа пользователей Линукс, Гомель, Беларусь
Keywords-en: Linux, Unix, LUG, Oleg P. Philon, articles, Gomel, Belarus, ex-USSR, hacker, hacks, Debian, free software, shell, bash, textutils, awk, perl, mysql, sql, consultant, expert, microhack, tricks, tips, russian, education, example
Keywords-ru: Линукс, Юникс, Гомель, Беларусь, пользователи Линукс, Олег П. Филон, статьи, хаки, хакеры, эксперт, консультант, администрирование, серверы, сети, помощь, обучение, пример, микрохаки
Author: Олег П. Филон
Copyright: FDL, Олег П. Филон
E-mail: ophil44@gmail.com
Date: 2002-12-22
Version: 1.1
Style-file: gulag.css
Script-file: gulag.js
Footer: g-footer
Ext-table: x-table.m4

extable(,Сольные выступления, articles.gif,
См. также
<br><br>
_link(lab-rab-mysql.html, Лабораторная работа по реляционным СУБД и языку SQL)
<br><br>
_link(micro-hacks.html, Микро хаки: советы и приемы эффективной работы)
<br><br>
_link(sketch_o_heroes.html, Этюд о героях невидимого фронта)
)
_strong(Генерация случайного телефонного справочника
)
<p align=right><i>Copyright(С) Олег П. Филон<br>
январь 2001, Гомель, BY<br>
_link(mailto:ophil44@gmail.com, ophil44@gmail.com)</i><br>

Возьмем любой текстовый файл, содержащий много русских слов. Далее
мы будем из них случайным образом выбирать отдельные слова
для якобы фамилий и названий улиц, поэтому в первую очередь
преобразуем этот файл в список слов:
_pre(
...$ tr -d '!-~'&lt;russian.text|tr ' ' '\n'|tr -s '\n'&gt;russian.words
)

У программы tr, как у всех textutils, есть хорошая документация
в виде info-файла, доступная через 
_pre(
...$ info -f textutils
)

На всякий случай поясню, что первый вызов tr удаляет из текста
почти все символы, кроме русских букв и пробелов. Второй вызов tr
преобразует все пробелы в символы новой строки, а третий tr
удаляет пустые строки.

Для единообразия добавим еще одну трансформацию:
_pre(
...$ tr Ю-Ъ ю-ъ&lt;russian.words&gt;words
)

Эта трансляция символов преобразует прописные буквы в строчные.
Такие странные диапазоны символов нужны из-за используемой
в Интернете и в Юниксе кодировки КОИ-8, в которой буквы расположены
вот в таком порядке:
_pre(
 юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ
)

Если у вас проблемы с ятями Ъ и ъ, для большинства текстов вполне хватит
диапазонов 'Ю-Ч' и 'ю-ч'. Конечно, я не помню кодировку КОИ-8 наизусть,
и не набивал эту строку вручную, а воспользовался вездесущим perl'ом:
_pre(
...$ perl -e 'use locale;print grep/\w/,map{chr()}128..255'
)

Возможно, это поможет вам разобраться с вашей кодировкой и справиться
с различием регистра букв в вашей системе.

Теперь мы хотим создать подобие телефонного справочника вот с такими
пятью полями: 
_pre(`
	1. номер телефона
	2. фамилия и.о.
	3. улица
	4. номер дома
	5. номер квартиры
')

и разделенными знаками табуляции. Для меня ближайшей программой,
подходящей для этой задачи, является интерпретатор awk. Вот что у меня
получилось - текст программы на языке AWK:
_pre(
BEGIN {       # этот блок выполняется 1 раз при запуске скрипта
    while((getline word&lt;"words")&gt;0)
	{   i++               #  индекс
	    words[i]=word     #  массив слов
	}
    srand()   # инициализация датчика случайных чисел
    u=1000    # максимальное количество улиц в нашем справочнике
    b=100     #         -- "" --      зданий на улице
    k=200     #         -- ""  --     квартир в здании
}
{             #  эти операторы выполняются для каждой строки
    n=int(i*rand())            # индекс превратился в размер массива
    m=int(i*rand())            # n и m - случайные числа
			       #                в заданном диапазоне
    s=int(1+i*int(u*rand())/u) # s - случайное, не более u разных
    print $1 "\t"\
	  words[n],\
	  substr(words[m],1,1)"."substr(words[m],2,1)".\t"\
	  words[s] "\t"\
          int(b*rand()+1) "\t"\
          int(k*rand()+1)
}
)

AWK необычный язык. Но стоит понять метафору, скрытую в нем, и программы
станут вполне читабельными. AWK берет строки из стандартного ввода,
разбивает их на слова, а дальше смотрит, нужно ли применять к строке
или отдельным словам указанные операторы. Много лет назад без лишнего
шума AWK стал работать со словами и со строками как с объектами, просто
указывая контекст и выполняемые в нем операции.

В нашем случае при старте подготовленный заранее список слов запоминается
в массиве, а далее все строки обрабатываются одинаково. В языке AWK
все массивы ассоциативные, то, что в Perl стало впоследствии хеш-массивом,
но, как видите, с таким массивом можно обращаться как с обычным, индексируемым
целым числом.

Остался последний штрих. Пусть файл с программой на AWK
называется "create-phones-db.awk". Подадим ему на
вход список якобы телефонных номеров и сохраним результат
в файле "phones.txt"
_pre(
...$ seq 100000 200000|awk -f create-phones-db.awk&gt;phones.txt
)

Готово. Размер файла регулируйте по вкусу, и не забудьте
удалить лишние файлы.
